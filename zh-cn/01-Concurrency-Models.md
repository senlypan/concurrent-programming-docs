# 并发模型

> 作者: 雅各布·詹科夫
>
> 原文: http://tutorials.jenkov.com/java-concurrency/concurrency-models.html 最后更新: 2022-02-23

并发系统可以采用多种并发编程模型来实现。并发模型指定了系统中的线程如何通过协作来完成分配给它们的作业。不同的并发模型采用不同的方式拆分作业，同时线程间的协作和交互方式也不相同。这篇并发模型教程将深入探讨撰写本文时（2015-2019）使用的最流行的几种并发模型。

## 并发模型和分布式系统的相似之处

本文所描述的并发模型类似于分布式系统中使用的很多体系结构。在并发系统中线程之间可以相互通信。在分布式系统中进程之间也可以相互通信（进程有可能在不同的机器中）。线程和进程之间具有很多相似的特性。这也就是为什么很多并发模型通常类似于各种分布式系统架构

当然，分布式系统有额外的挑战，网络可能会出现故障，或者远程计算机或进程出现故障等。但是在大型服务器上运行的并发系统可能会遇到类似的问题，例如 CPU 故障、网卡故障、磁盘故障等等。失败的概率可能会更低，但理论上它仍然可以发生。

由于并发模型类似于分布式系统架构，因此它们通常可以互相借鉴思想。例如，为工作线程（worker threads）之间分配工作的模型通常类似于 [分布式系统中的负载均衡](http://tutorials.jenkov.com/software-architecture/load-balancing.html) 模型。同样，在日志记录、故障转移、任务幂等性等错误处理技术上也是如此。

## 共享状态与分离状态

并发模型的一个重要方面是，组件和线程是否被设计为在线程之间共享状态，或者具有从不在线程之间共享的分离状态。

> 状态是指一些数据，通常是一个或多个对象或类似的。当线程共享状态时，可能会出现[资源竞争](http://tutorials.jenkov.com/java-concurrency/race-conditions-and-critical-sections.html) 和 [死锁](http://tutorials.jenkov.com/java-concurrency/deadlock.html) 等问题。当然，这取决于线程如何使用和访问共享对象。

共享状态意味着系统中的不同线程之间会共享一些状态，这些状态通常指一些数据，可能是一个或多个对象。当线程共享状态时，可能会出现例如 [资源竞争](http://tutorials.jenkov.com/java-concurrency/race-conditions-and-critical-sections.html) 和 [死锁](http://tutorials.jenkov.com/java-concurrency/deadlock.html) 等问题。 当然，这要取决于线程之间是如何使用和访问共享对象的。

![01-Concurrency-Models#concurrency-models-0-1.png](http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-0-1.png)

分离状态是指系统中的不同线程之间不共享任何状态。如果不同的线程需要通信，它们要么通过在它们之间交换不可变对象，要么通过在它们之间发送对象（或数据）的副本来实现。因此，当没有两个线程写入同一个对象（数据/状态）时，可以避免大多数常见的并发问题。

![01-Concurrency-Models#concurrency-models-0-2.png](http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-0-2.png)

使用单独的状态并发设计通常可以使代码的某些部分更易于实现和推理，因为您知道只有一个线程会写入给定对象。您不必担心对该对象的并发访问。但是，您可能需要从大局考虑应用程序设计，以使用单独的状态并发。不过还是值得的，我觉得。我个人更喜欢单独的状态并发设计。

## 并行工作者模型

第一种并发模型就是我所说的并行工作者模型。传入的作业会被分配到不同的工作者上。下图展示了并行工作者模型：

![01-Concurrency-Models#concurrency-models-1.png](http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-1.png)

在并行工作者模型中，委派者（Delegator）将传入的作业分配给不同的工作者。每个工作者完成整个任务。工作者们并行运作在不同的线程上，甚至可能在不同的CPU上。

> 每个worker完成整个任务

如果在某个汽车厂里实现了并行工作者模型，每台车都会由一个工人来生产。工人们将拿到汽车的生产规格，并且从头到尾负责所有工作。

在Java应用系统中，并行工作者模型是最常见的并发模型（即使正在转变）。[java.util.concurrent](http://tutorials.jenkov.com/java-util-concurrent/index.html) 这个并发包中很多工具都是基于这个模型设计的。你也可以在Java企业级（J2EE）应用服务器的设计中看到这个模型的影子。

并行工作者并发模型可以设计为使用共享状态或分离状态，这意味着工作者要么可以访问某些共享状态（共享对象或数据），要么没有共享状态。

## 并行工作者模型的优点

并行工作者模型的优点是，它很容易理解。你只需添加更多的工作者来提高系统的并行度。

举个例子，如果你正在做一个网络爬虫，可以试试使用不同数量的工作者抓取到一定数量的页面，然后看看多少数量的工作者消耗的时间最短（意味着性能最高）。由于网络爬虫是一个IO密集型工作，最终结果很有可能是你电脑中的每个CPU或每个核分配了几个线程。每个CPU若只分配一个线程可能有点少，因为在等待数据下载的过程中CPU将会空闲大量时间。

## 并行工作者模型的缺点

并行工作者模型虽然看起来简单，却隐藏着一些缺点。接下来的章节中我会分析一些比较明显的不足。

### 共享状态可能会很复杂

在实际应用中，并行工作者模型可能比前面所描述的情况要复杂得多。共享的工作者经常需要访问一些共享数据，无论是内存中的或者共享的数据库中的。下图展示了并行工作者模型是如何变得复杂的：

![01-Concurrency-Models#concurrency-models-2.png](http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-2.png)

其中一些共享状态存在于通信机制中，例如作业队列。但其中一些共享状态是业务数据、数据缓存、数据库连接池等。

一旦共享状态潜入到并行工作者模型中，将会使情况变得复杂起来。线程需要以某种方式存取共享数据，以确保某个线程的修改能够对其他线程可见（数据修改需要同步到主存中，不仅仅将数据保存在执行这个线程的CPU的缓存中）。线程需要避免 [资源竞争](http://tutorials.jenkov.com/java-concurrency/race-conditions-and-critical-sections.html) , [死锁](http://tutorials.jenkov.com/java-concurrency/deadlock.html) 以及其他一些由于共享状态而导致的并发问题。

此外，在等待访问共享数据结构时，线程之间的互相等待将会丢失部分并行性。许多并发数据结构是阻塞的，意味着在任何一个时间只有一个或者很少的线程能够访问。这样会导致在这些共享数据结构上出现竞争状态。在执行需要访问共享数据结构部分的代码时，高竞争基本上会导致执行时出现一定程度的串行化。

现在的 [非阻塞并发算法](http://tutorials.jenkov.com/java-concurrency/non-blocking-algorithms.html) 也许可以降低竞争并提升性能，但是非阻塞算法的实现比较困难。

可持久化的数据结构是另一种选择。在修改的时候，可持久化的数据结构总是保护它的前一个版本不受影响。因此，如果多个线程指向同一个可持久化的数据结构，并且其中一个线程进行了修改，进行修改的线程会获得一个指向新结构的引用。所有其他线程保持对旧结构的引用，旧结构没有被修改并且因此保证一致性。Scala 标准 API 包含几个持久数据结构。

【注：这里的可持久化数据结构不是指持久化存储，而是一种数据结构，比如Java中的String类，以及CopyOnWriteArrayList类，具体可参考】

虽然可持久化的数据结构在解决共享数据结构的并发修改时显得很优雅，但是可持久化的数据结构的表现往往不尽人意。

比如说，一个可持久化的链表需要在头部插入一个新的节点，并且返回指向这个新加入的节点的一个引用（这个节点指向了链表的剩余部分）。所有其他线程仍然保留对列表中先前第一个元素的引用，并且对于这些线程，列表看起来没有变化。他们看不到新添加的元素。

这种可持久化的列表采用链表来实现。不幸的是链表在现代硬件上表现的不太好。链表中得每个元素都是一个独立的对象，这些对象可以遍布在整个计算机内存中。现代CPU能够更快的进行顺序访问，所以你可以在现代的硬件上用数组实现的列表，以获得更高的性能。数组可以顺序的保存数据。CPU缓存能够一次加载数组的一大块进行缓存，一旦加载完成CPU就可以直接访问缓存中的数据。这对于元素散落在RAM中的链表来说，不太可能做得到。

### 无状态的工作者

共享状态可以被系统中的其他线程修改。因此，工作人员必须在每次需要时重新读取状态，以确保他们正在处理最新的副本。无论共享状态是保存在内存中还是保存在外部数据库中，都是如此。内部不保存状态（但每次需要时都会重新读取）的工作者称为无状态。

每次需要时重新读取数据，可能会导致速度变慢，特别是状态保存在外部数据库中的时候。

### 任务顺序是不确定的

并行工作者模型的另一个缺点是作业执行顺序是不确定的。无法保证首先执行哪些作业或最后执行哪些作业。作业A可能在作业B之前就被分配工作者了，但是作业B反而有可能在作业A之前执行。

并行工作者模型的这种不确定性，使得很难在任何特定的时间点推断系统的状态。这也使得保证一项任务先于另一项任务完成变得更加困难（如果不是不可能的话）。然而，这并不总是导致问题。这取决于系统的需要。

## 流水线模型（串行模型）

第二种并发模型就是我所说的流水线并发模型。我选择这个名字只是为了符合前面提到的“并行工作者”的比喻。其他开发人员根据平台/社区使用其他名称（例如反应式系统或事件驱动系统）。这是一个说明流水线并发模型的图表：

![01-Concurrency-Models#concurrency-models-3.png](http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-3.png)

> 每个worker只完成全部工作的一部分

工人像工厂流水线上的工人一样被组织起来。每个工人只完成全部工作的一部分。当该部分完成后，工人将工作转发给下一个工人。

使用流水线并发模型的系统通常设计为使用非阻塞 IO。非阻塞 IO 意味着当工作人员开始 IO 操作（例如从网络连接读取文件或数据）时，工作人员不会等待 IO 调用完成。IO 操作很慢，所以等待 IO 操作完成是对 CPU 时间的浪费。与此同时，CPU 可能正在做其他事情。当 IO 操作完成时，IO 操作的结果（例如数据读取或数据写入状态）将传递给另一个工作人员。

使用非阻塞 IO，IO 操作决定了 worker 之间的边界。一个工作人员尽可能多地做，直到它必须开始一个 IO 操作。然后它放弃了对工作的控制。当 IO 操作完成时，流水线中的下一个工人继续工作，直到也必须开始 IO 操作等。

![01-Concurrency-Models#concurrency-models-4.png](http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-4.png)

实际上，这些工作可能不会沿着一条流水线流动。由于大多数系统可以执行多个作业，因此作业从一个工作人员流向另一个工作人员，这取决于接下来需要执行工作的哪一部分。实际上，可能有多个不同的虚拟流水线同时运行。这就是通过流水线系统的工作流在现实中的样子：

![01-Concurrency-Models#concurrency-models-5.png](http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-5.png)

作业甚至也有可能被转发到超过一个工作者上并发处理。比如说，作业有可能被同时转发到作业执行器和作业日志器。下图说明了三条流水线是如何通过将作业转发给同一个工作者（中间流水线的最后一个工作者）来完成作业:

![01-Concurrency-Models#concurrency-models-6.png](http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-6.png)

流水线可以变得比这更复杂。

### 响应式、事件驱动系统

采用流水线并发模型的系统有时候也称为响应式系统或事件驱动系统。系统内的工作者对系统内出现的事件做出响应，这些事件有可能来自于外部系统或者内部其他工作者。事件可以是传入的HTTP请求，也可以是某个文件成功加载到内存中等。在写这篇文章的时候，已经有很多有趣的响应式/事件驱动平台可以使用了，并且不久的将来会有更多。比较流行的似乎是这几个：

- [Vert.x](http://tutorials.jenkov.com/vert.x/index.html)
- Akka
- Node.JS (JavaScript)

我个人觉得Vert.x是相当有趣的（特别是对于我这样使用Java/JVM的人来说）

### Actors vs. Channels

Actors 和 channels 是两种比较类似的流水线（或响应式/事件驱动）模型。

在Actor模型中每个工作者被称为actor。Actor之间可以直接异步地发送和处理消息。Actor可以被用来实现一个或多个像前文描述的那样的作业处理流水线。下图给出了Actor模型：

![01-Concurrency-Models#concurrency-models-7.png](http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-7.png)

而在Channel模型中，工作者之间不直接进行通信。相反，它们在不同的通道中发布自己的消息（事件）。其他工作者们可以在这些通道上监听消息，发送者无需知道谁在监听。下图给出了Channel模型：

![01-Concurrency-Models#concurrency-models-8.png](http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-8.png)

在写这篇文章的时候，channel模型对于我来说似乎更加灵活。一个工作者无需知道谁在后面的流水线上处理作业。只需知道作业（或消息等）需要转发给哪个通道。通道上的监听者可以随意订阅或者取消订阅，并不会影响向这个通道发送消息的工作者。这使得工作者之间具有松散的耦合。

## 流水线模型（串行模型）的优点

与并行工作者模型相比，流水线并发模型具有几个优点，我将在以下部分介绍最大的优势。

### 无共享的状态

工作者之间无需共享状态，意味着实现的时候无需考虑所有因并发访问共享对象而产生的并发性问题。这使得在实现工作者的时候变得非常容易。在实现工作者的时候就好像是单个线程在处理工作-基本上是一个单线程的实现。

### 有状态的工作者

当工作者知道了没有其他线程可以修改它们的数据，工作者可以变成有状态的。对于有状态，我是指，它们可以在内存中保存它们需要操作的数据，只需在最后将更改写回到外部存储系统。因此，有状态的工作者通常比无状态的工作者具有更高的性能。

### 更好的硬件一致性

单线程代码的优势在于它通常更符合底层硬件的工作方式。首先，当您可以假设代码以单线程模式执行时，您通常可以创建更优化的数据结构和算法。

其次，单线程有状态工作者可以将数据缓存在内存中，如上所述。当数据缓存在内存中时，该数据也很有可能缓存在执行线程的 CPU 的 CPU 缓存中。这使得访问缓存数据的速度更快。

当代码以自然受益于底层硬件工作方式的方式编写时， 我将其称为硬件一致性。一些开发者称之为机械共情。我更倾向于硬件整合这个术语，我更喜欢硬件一致性这个词，因为计算机只有很少的机械部件，并且能够隐喻 “更好的匹配” ，相比 “共情” 这个词在上下文中的意思，我觉得 “一致性” 更能传达那个味儿。当然了，这里有点吹毛求疵了，用自己喜欢的术语就行。

### 可控的任务顺序

基于流水线并发模型实现的并发系统，在某种程度上是有可能保证作业的顺序的。作业的有序性使得它更容易地推出系统在某个特定时间点的状态。更进一步，你可以将所有到达的作业写入到日志中去。一旦这个系统的某一部分挂掉了，该日志就可以用来重头开始重建系统当时的状态。按照特定的顺序将作业写入日志，并按这个顺序作为有保障的作业顺序。下图展示了一种可能的设计：

![01-Concurrency-Models#concurrency-models-9.png](http://tutorials.jenkov.com/images/java-concurrency/concurrency-models-9.png)

实现一个有保障的作业顺序是不容易的，但往往是可行的。如果可以，它将大大简化一些任务，例如备份、数据恢复、数据复制等，这些都可以通过日志文件来完成。

## 流水线模型（串行模型）的缺点

流水线并发模型最大的缺点是作业的执行往往分布到多个工作者上，并因此分布到项目中的多个类上。这样导致在追踪某个作业到底被什么代码执行时变得困难。

同样，这也加大了代码编写的难度。有时会将工作者的代码写成回调处理的形式。若在代码中嵌入过多的回调处理，往往会出现所谓的回调地狱（callback hell）现象。所谓回调地狱，就是意味着在追踪代码在回调过程中到底做了什么，以及确保每个回调只访问它需要的数据的时候，变得非常困难

使用并行工作者模型可以简化这个问题。你可以打开工作者的代码，从头到尾优美的阅读被执行的代码。当然并行工作者模式的代码也可能同样分布在不同的类中，但往往也能够很容易的从代码中分析执行的顺序。

## 函数式并行

第三种并发模型是函数式并行模型，这也是最近（2015）讨论的比较多的一种模型。

函数式并行的基本思想是采用函数调用实现程序。函数可以看作是”代理人（agents）“或者”actor“，函数之间可以像流水线模型（AKA 响应式或者事件驱动系统）那样互相发送消息。某个函数调用另一个函数，这个过程类似于消息发送。

函数都是通过拷贝来传递参数的，所以除了接收函数外没有实体可以操作数据。这对于避免共享数据的资源竞争来说是很有必要的。同样也使得函数的执行类似于原子操作。每个函数调用的执行独立于任何其他函数的调用。

一旦每个函数调用都可以独立的执行，它们就可以分散在不同的CPU上执行了。这也就意味着能够在多处理器上并行的执行使用函数式实现的算法。

Java7中的 `java.util.concurrent` 包里包含的ForkAndJoinPool能够帮助我们实现类似于函数式并行的一些东西。而Java8中并行streams能够用来帮助我们并行的迭代大型集合。请记住，有些开发者对ForkAndJoinPool进行了批判（你可以在我的ForkAndJoinPool教程里面看到批评的链接）。

函数式并行里面最难的是确定需要并行的那个函数调用。跨CPU协调函数调用需要一定的开销。某个函数完成的工作单元需要达到某个大小以弥补这个开销。如果函数调用作用非常小，将它并行化可能比单线程、单CPU执行还慢。

我个人认为（可能不太正确），你可以使用响应式或者事件驱动模型实现一个算法，像函数式并行那样的方法实现工作的分解。使用事件驱动模型可以更精确的控制如何实现并行化（我的观点）。

此外，将任务拆分给多个CPU时协调造成的开销，仅仅在该任务是程序当前执行的唯一任务时才有意义。但是，如果当前系统正在执行多个其他的任务时（比如web服务器，数据库服务器或者很多其他类似的系统），将单个任务进行并行化是没有意义的。不管怎样计算机中的其他CPU们都在忙于处理其他任务，没有理由用一个慢的、函数式并行的任务去扰乱它们。使用流水线（响应式）并发模型可能会更好一点，因为它开销更小（在单线程模式下顺序执行）同时能更好的与底层硬件一致。

## 哪种并发模型最好？

那么，哪种并发模型更好呢？

通常情况下，这个答案取决于你的系统打算做什么。如果你的作业本身就是并行的、独立的并且没有必要共享状态，你可能会使用并行工作者模型去实现你的系统。

但是，许多工作并不是天生并行和独立的。对于这类系统，我相信使用流水线并发模型会利大于弊，比并行工作模型的优点更多。

您甚至不必自己编写所有流水线的基础设计。像 [Vert.x](http://tutorials.jenkov.com/vert.x/index.html) 这样的现代平台已经为你实现了很多。就我个人而言，我将为我的下一个项目探索在 Vert.x 等平台上运行的设计。我觉得 Java EE 不太有优势了。

（本篇完）

?> ✨ 译文来源：[潘深练](https://www.panshenlian.com)，[并发编程网 – ifeve.com](http://ifeve.com/%e5%b9%b6%e5%8f%91%e7%bc%96%e7%a8%8b%e6%a8%a1%e5%9e%8b/) 如您有更好的翻译版本，欢迎 ❤️ 提交 [issue](https://github.com/senlypan/concurrent-programming-docs/issues) 或投稿哦~
