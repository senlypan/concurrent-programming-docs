# 多线程的代价

> 作者: 雅各布·詹科夫
>
> 原文: http://tutorials.jenkov.com/java-concurrency/costs.html 最后更新: 2022-02-23

从一个单线程的应用到一个多线程的应用并不仅仅带来好处，它也会有一些代价。不要仅仅为了使用多线程而使用多线程。而应该明确在使用多线程时能得到的好处比所付出的代价大的时候，才使用多线程。如果存在疑问，应该尝试测量一下应用程序的性能和响应能力，而不只是猜测。

?> 并发编程的目的是为了让程序运行得更快，但是，并不是启动更多的线程就能让程序最大限度地并发执行。在进行并发编程时，如果希望通过多线程执行任务让程序运行得更快，会面临非常多的 **挑战** ，例如 程序设计的`复杂性`、`上下文切换`的问题、`死锁`的问题，以及受限于`硬件和软件的资源限制`问题等。

## 设计更复杂

虽然有一些多线程应用程序比单线程的应用程序要简单，但其他的一般都会更复杂。在多线程 **访问共享数据** 的时候，这部分代码需要特别注意。线程之间的交互往往非常复杂。不正确的线程同步产生的错误非常难以被发现、重现以及修复。

## 上下文切换的开销

?> 即使是单线程处理器也支持多线程执行代码，CPU通过给每个线程分配CPU时间片来实现这个机制。时间片是CPU分配给各个线程的时间，因为时间片非常短，所以CPU通过不停地切换线程执行，让我们感觉多个线程是同时执行的，时间片一般是几十毫秒（ms）。CPU通过 **时间片分配算法** 来循环执行多个任务，当前任务执行一个时间片后会切换到下一个任务。但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是 **一次上下文切换** 。

当CPU从执行一个线程切换到执行另外一个线程的时候，它需要先存储当前线程的本地的数据，程序指针等，然后载入另一个线程的本地数据，程序指针等，最后才开始执行。这种切换称为“上下文切换”(“context switch”)。CPU会在一个上下文中执行一个线程，然后切换到另外一个上下文中执行另外一个线程。

上下文切换并不廉价。如果没有必要，应该减少上下文切换的发生。

你可以通过维基百科阅读更多的关于上下文切换相关的内容：

http://en.wikipedia.org/wiki/Context_switch

> 如何减少上下文切换？

减少上下文切换的方法有`无锁并发编程`、`CAS算法`、`使用最少线程`和`使用协程`。

1. 无锁并发编程。多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如讲数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据。

2. CAS算法。 Java的 Atomic 包使用CAS算法来更新数据，而不需要加锁。（当然CAS算法会存在三大问题：ABA问题，循环时间长开销大，以及只能保证一个共享变量的原子操作）

3. 使用最少线程。避免创建不需要的线程，比如任务很少，但是却创建了很多线程来处理，这样会造成大量线程都处于等待状态。（线程从 WAITING 到 RUNNABLE 状态都会进行一次上下文的切换，WAITING 的线程少了，系统上下文切换的次数就会减少）

4. 协程。在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。

## 死锁

锁是个非常有用的工具，运用场景非常多，因为它使用起来非常简单，而且容易理解。但同时它也会带来一些困扰，那就是可能会引起死锁，它会造成系统功能不可用。

例如线程1和线程2，同时争抢资源A,资源B，由于资源先后获得，并且互相等待对方释放锁，导致死锁。

``` text
线程1  : -----> 获取A（加锁）-----> sleep(5000) -----> 获取B（等待A）
线程2  : -----> 获取B（加锁）-----> 获取A （等待B）
```

> 避免死锁的几个常见方法

1. 避免一个线程同时获取多个锁

2. 避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源

3. 尝试使用定时锁，使用 lock.tryLock(timeout) 来替代使用内部锁机制

4. 对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。

## 增加资源消耗

线程在运行的时候需要从计算机里面得到一些资源。除了CPU，线程还需要一些内存来维持它本地的堆栈。它也需要占用操作系统中一些资源来管理线程。我们可以尝试编写一个程序，让它创建100个线程，这些线程什么事情都不做，只是在等待，然后看看这个程序在运行的时候占用了多少内存。

## 资源限制的挑战

1. **硬件资源限制**。服务器的带宽只有2Mb/s，某个资源的下载速度是 1Mb/s ，那么即使系统启动100个线程下载资源，下载速度也不会变成100Mb/s，所以在进行并发编程时，要考虑这些资源的限制。

2. **软件设计限制**。进行一个数据库批量操作，系统启动100个线程进行操作，但是由于数据库连接数只有20个，导致某些线程会被阻塞，等待数据库连接。

（本篇完）

?> ✨ 译文来源：[潘深练](http://www.panshenlian.com)，[并发编程网 – ifeve.com](http://ifeve.com/costs-of-multithreading/) 如您有更好的翻译版本，欢迎 ❤️ 提交 [issue](https://github.com/senlypan/concurrent-programming-docs/issues) 或投稿哦~